#' Estimation of the reproduction number with Laplacian-P-splines
#'
#' @description
#' This routine estimates the instantaneous reproduction number Rt (the mean number
#' of secondary cases generated by an infectious individual at time t, White et
#' al. 2020) using Bayesian P-splines and Laplace approximations. The
#' \code{epilps()} routine estimates Rt based on a time series of incidence
#' counts and a given serial interval distribution. The negative
#' Binomial distribution is used to model incidence count data and P-splines
#' (Eilers and Marx, 1996) are used to smooth the epidemic curve. The link
#' between the epidemic curve and the reproduction number is established via the
#' renewal equation. If \code{incidence} contains NA values at certain time
#' points, these are replaced by the average of the left- and right neighbor
#' counts. If the right neighbor is NA, the left neighbor is used as a
#' replacement value.
#'
#' @usage estimR(incidence, si, K = 30, dates = NULL, cimethod = 1, CoriR = FALSE, WTR = FALSE)
#'
#' @param incidence A vector containing the time series of incidence counts.
#' @param si The discrete serial interval distribution.
#' @param K Number of B-splines in the basis.
#' @param dates A vector of date values (optional).
#' @param cimethod The method used to construct credible intervals for Rt
#'  Default is 1 (log-normal approx) with scaling correction
#'  on the covariance matrix. Setting it to 2 ignores the scaling correction.
#' @param CoriR Should the Rt estimate be also computed with the method of Cori?
#' @param WTR Should the Rt estimate be also computed with the Wallinga-Teunis
#' approach?
#'
#' @return An object of class \code{epilps} containing the pointwise and set
#'  estimates of the time-varying reproduction number and the epidemic curve
#'  respectively.
#'
#' @author Oswaldo Gressani \email{oswaldo_gressani@hotmail.fr}
#'
#' @references Gressani, O., Wallinga, J., Althaus, C. L., Hens, N. and Faes, C.
#'  (2022). EpiLPS: A fast and flexible Bayesian tool for estimation of the
#'  time-varying reproduction number. \emph{Plos Computational Bioloby},
#'  \strong{18(10): e1010618}.
#' @references White, L.F., Moser, C.B., Thompson, R.N., Pagano, M. (2021).
#'  Statistical estimation of the reproductive number from case notification
#'  data. \emph{American Journal of Epidemiology}, \strong{190}(4):611-620.
#' @references Eilers, P.H.C. and Marx, B.D. (1996). Flexible smoothing
#'  with B-splines and penalties. \emph{Statistical Science},
#'  \strong{11}(2):89-121.
#'
#' @examples
#' si <- c(0.05, 0.05, 0.1, 0.1, 0.1, 0.1, 0.1, 0.05, 0.05, 0.1, 0.1, 0.1)
#' epidemic <- episim(serial_interval = si, Rpattern = 2, endepi = 30)
#' epifit <- estimR(incidence = epidemic$y, si = si)
#' plot(epifit)
#'
#' @export

estimR <- function(incidence, si, K = 30, dates = NULL, cimethod = 1,
                    CoriR = FALSE, WTR = FALSE){

  tic <- proc.time()             # Clock starts ticking
  y <- KerIncidCheck(incidence)  # Run checks on case incidence vector
  n <- length(y)                 # Total number of days of the epidemic
  simax <- length(si)            # Length of serial interval distribution
  B <- Rcpp_cubicBspline(seq_len(n), lower = 1, upper = n, K = K) # C++ call
  D <- diag(K)
  penorder <- 2
  for(k in 1:penorder){D <- diff(D)}
  P <- t(D) %*% D           # Penalty matrix of dimension c(K,K)
  P <- P + diag(1e-06, K)   # Perturbation to ensure P is full rank

  # Minus log-posterior of hyperparameter vector
  logphyper <- function(x) {
    w <- x[1] # w = log(rho)
    v <- x[2] # v = log(lambda)

    # Laplace approximation
    LL <- Rcpp_Laplace(exp(w), exp(v), K,
                       KerPtheta(Dobs = y, BB = B, Pen = P)$Dlogptheta,
                       KerPtheta(Dobs = y, BB = B, Pen = P)$D2logptheta)
    thetastar <- as.numeric(LL$Lapmode)
    logdetSigstar <- Re(LL$logdetSigma)

    equal <- (-1) * (0.5 * logdetSigstar + 0.5 * (K + 2) * v + 1e-04 * w -
                       (0.5 * 2 + 10) * log(0.5 * 2 * exp(v) + 10) +
                       KerLikelihood(Dobs = y, BB = B)$loglik(thetastar, exp(w)) -
                       0.5 * exp(v) * sum((thetastar * P) %*% thetastar) -
                       1e-04 * exp(w))

    return(equal)
  }

  # Maximization of the posterior hyperparameters
  hypermap <- stats::optim(c(1, 5), fn = logphyper)$par
  disphat <- exp(hypermap[1])
  lambhat <- exp(hypermap[2])
  Lap_approx <- Rcpp_Laplace(disphat, lambhat, K,
                             KerPtheta(Dobs = y, BB = B, Pen = P)$Dlogptheta,
                             KerPtheta(Dobs = y, BB = B, Pen = P)$D2logptheta)
  thetahat <- as.numeric(Lap_approx$Lapmode)
  muhat <- as.numeric(exp(B %*% thetahat))
  Sighat <- Lap_approx$Lapvar

  # Check if a correction of CI on R should be done
  cratio <- (1 + (1 / disphat) * mean(muhat)) / disphat
  if (cratio <= 1) {
    EMV <- (1 / (1 + muhat / disphat))
  } else if (cratio > 1 || cimethod == 2) {
    EMV <- rep(1, n)
  }

  if(is.null(dates)) {
    Time <- seq_len(n)
  } else{
    Time <- dates
  }

  # Computation of summary statistics for reproduction number with LPS
  RLPS <- KerRpostmap(BB = B, theta = thetahat, Covar = Sighat, sinter = si,
                      MVvec = EMV, Tdom = Time)

  if (CoriR == TRUE) {# Use Cori method with weekly sliding windows
    RCori <- KerCori(Dobs = incidence, sinter = si)
  } else{
    RCori <- "Not called"
  }

  if(WTR == TRUE){# Use Wallinga-Teunis method to estimate R
    RWT <- KerWT(Dobs = incidence, sinter = si)
  } else{
    RWT <- "Not called"
  }

  toc <- proc.time() - tic
  toc <- round(toc[3], 3)

  #-- Output results in a list
  outputlist <- list(incidence = y, si = si, RLPS = RLPS,
                     RCori = RCori, RWT = RWT,
                     elapsed = toc, penparam = lambhat, K = K,
                     NegBinoverdisp = disphat, method = "LPSMAP")



  attr(outputlist, "class") <- "epilps"
  outputlist
}








