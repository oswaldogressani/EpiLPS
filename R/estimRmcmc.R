#' Estimation of the reproduction number with Laplacian-P-splines via MCMC
#'
#' @description
#' This routine estimates the instantaneous reproduction number Rt (the mean number
#' of secondary cases generated by an infectious individual at time t, White et
#' al. 2020) using Bayesian P-splines and Laplace approximations. The inference
#' approach is fully stochastic with a Metropolis-adjusted Langevin algorithm. The
#' \code{estimRmcmc()} routine estimates Rt based on a time series of incidence
#' counts and a given serial interval distribution. The negative
#' Binomial distribution is used to model incidence count data and P-splines
#' (Eilers and Marx, 1996) are used to smooth the epidemic curve. The link
#' between the epidemic curve and the reproduction number is established via the
#' renewal equation. If \code{incidence} contains NA values at certain time
#' points, these are replaced by the average of the left- and right neighbor
#' counts. If the right neighbor is NA, the left neighbor is used as a
#' replacement value.
#'
#' @usage estimRmcmc(incidence, si, K = 30, niter = 5000, burnin = 2000, dates = NULL,
#'  CoriR = FALSE, WTR = FALSE)
#'
#' @param incidence A vector containing the time series of incidence counts.
#' @param si The discrete serial interval distribution.
#' @param K Number of B-splines in the basis.
#' @param niter Number of iterations for the MCMC sampler.
#' @param burnin The burnin size.
#' @param dates A vector of date values (optional).
#' @param CoriR Should the Rt estimate be also computed with the method of Cori?
#' @param WTR Should the Rt estimate be also computed with the Wallinga-Teunis
#' approach?
#'
#' @return An object of class \code{epilps} containing the pointwise and set
#'  estimates of the time-varying reproduction number and the epidemic curve
#'  respectively.
#'
#' @author Oswaldo Gressani \email{oswaldo_gressani@hotmail.fr}
#'
#' @references Gressani, O., Wallinga, J., Althaus, C. L., Hens, N. and Faes, C.
#'  (2022). EpiLPS: A fast and flexible Bayesian tool for estimation of the
#'  time-varying reproduction number. \emph{Plos Computational Bioloby},
#'  \strong{18(10): e1010618}.
#' @references White, L.F., Moser, C.B., Thompson, R.N., Pagano, M. (2021).
#'  Statistical estimation of the reproductive number from case notification
#'  data. \emph{American Journal of Epidemiology}, \strong{190}(4):611-620.
#' @references Eilers, P.H.C. and Marx, B.D. (1996). Flexible smoothing
#'  with B-splines and penalties. \emph{Statistical Science},
#'  \strong{11}(2):89-121.
#'
#' @examples
#' si <- c(0.05, 0.05, 0.1, 0.1, 0.1, 0.1, 0.1, 0.05, 0.05, 0.1, 0.1, 0.1)
#' epidemic <- episim(serial_interval = si, Rpattern = 2, endepi = 30)
#' epifit <- estimRmcmc(incidence = epidemic$y, si = si)
#' plot(epifit)
#'
#' @export

estimRmcmc <- function(incidence, si, K = 30, niter = 5000, burnin = 2000,
                       dates = NULL, CoriR = FALSE, WTR = FALSE){
  tic <- proc.time()                      # Clock starts ticking
  y <- KerIncidCheck(incidence)  # Run checks on case incidence vector
  n <- length(y)                 # Total number of days of the epidemic
  simax <- length(si)            # Length of serial interval distribution
  B <- Rcpp_KercubicBspline(seq_len(n), lower = 1, upper = n, K = K) # C++ call
  D <- diag(K)
  penorder <- 2
  for(k in 1:penorder){D <- diff(D)}
  P <- t(D) %*% D           # Penalty matrix of dimension c(K,K)
  P <- P + diag(1e-06, K)   # Perturbation to ensure P is full rank

  # Minus log-posterior of hyperparameter vector
  logphyper <- function(x) {
    w <- x[1] # w = log(rho)
    v <- x[2] # v = log(lambda)

    # Laplace approximation
    LL <- Rcpp_KerLaplace(exp(w), exp(v), K,
                       KerPtheta(Dobs = y, BB = B, Pen = P)$Dlogptheta,
                       KerPtheta(Dobs = y, BB = B, Pen = P)$D2logptheta)
    thetastar <- as.numeric(LL$Lapmode)
    logdetSigstar <- Re(LL$logdetSigma)

    equal <- (-1) * (0.5 * logdetSigstar + 0.5 * (K + 2) * v + 1e-04 * w -
                       (0.5 * 2 + 10) * log(0.5 * 2 * exp(v) + 10) +
                       KerLikelihood(Dobs = y, BB = B)$loglik(thetastar, exp(w)) -
                       0.5 * exp(v) * sum((thetastar * P) %*% thetastar) -
                       1e-04 * exp(w))
    return(equal)
  }

  # Maximization of the posterior hyperparameters
  hypermap <- stats::optim(c(1, 5), fn = logphyper)$par
  disphat <- exp(hypermap[1])
  lambhat <- exp(hypermap[2])
  Lap_approx <- Rcpp_KerLaplace(disphat, lambhat, K,
                             KerPtheta(Dobs = y, BB = B, Pen = P)$Dlogptheta,
                             KerPtheta(Dobs = y, BB = B, Pen = P)$D2logptheta)
  thetahat <- as.numeric(Lap_approx$Lapmode)
  muhat <- as.numeric(exp(B %*% thetahat))
  Sighat <- Lap_approx$Lapvar

  # Call Metropolis-adjusted Langevin algorithm
  cat(paste0("Metropolis-adjusted Langevin algorithm running for ",niter,
             " iterations \n"))
  progbar <- utils::txtProgressBar(min = 1, max = niter, initial = 1,
                                   style = 3, char =">")
  MCMCout <- KerMCMC(Dobs = incidence, BB = B, Pen = P, Covar = Sighat,
                     thetaoptim = thetahat, penoptim = lambhat,
                     overdispoptim = disphat, progress = progbar)$MALA(M=niter)
  # Chain extraction
  lambdaMALA <- coda::as.mcmc(MCMCout$lambda_mcmc[(burnin+1):niter])
  deltaMALA <- coda::as.mcmc(MCMCout$delta_mcmc[(burnin+1):niter])
  rhoMALA <- coda::as.mcmc(MCMCout$rho_mcmc[(burnin+1):niter])
  thetaMALA <- coda::as.mcmc(MCMCout$theta_mcmc[(burnin+1):niter,])
  accept_mcmc <- MCMCout$accept_rate

  # Point estimation
  thetahat_mcmc  <- colMeans(thetaMALA)
  lambdahat_mcmc <-  mean(lambdaMALA)
  rhohat_mcmc <- mean(rhoMALA)
  muMALA_mcmc <- matrix(0, nrow = (niter - burnin), ncol = n)
  for(j in 1:(niter-burnin)){
    muMALA_mcmc[j,] <- as.numeric(exp(B %*% thetaMALA[j, ]))
  }
  mu_estim <- colMeans(muMALA_mcmc)

  if(is.null(dates)) {
    Time <- seq_len(n)
  } else{
    Time <- dates
  }

  RLPS <- data.frame(matrix(0, nrow = n, ncol = 10))
  colnames(RLPS) <- c("Time", "R", "Rsd", "Rq0.025", "Rq0.05","Rq0.25",
                      "Rq0.50","Rq0.75", "Rq0.95", "Rq0.975")
  RLPS$Time <- Time

  for(j in 1:n){
    CppCall <- as.numeric(Rcpp_KerRpostmcmc(t = j, BB = B, sinter = si,
                                            thetasample = thetaMALA))
    RLPS$R[j] <- mean(CppCall)
    RLPS$Rsd[j] <- stats::sd(CppCall)
    RLPS[j, (4:10)] <- stats::quantile(CppCall,
                                probs = c(0.025, 0.05, 0.25, 0.50, 0.75,
                                          0.95, 0.975))
  }

  if (CoriR == TRUE) {# Use Cori method with weekly sliding windows
    RCori <- KerCori(Dobs = incidence, sinter = si)
  } else{
    RCori <- "Not called"
  }

  if(WTR == TRUE){# Use Wallinga-Teunis method to estimate R
    RWT <- KerWT(Dobs = incidence, sinter = si)
  } else{
    RWT <- "Not called"
  }

  toc <- proc.time() - tic
  toc <- round(toc[3], 3)

  #-- Output results in a list
  outputlist <- list(incidence = y, si = si, RLPS = RLPS,
                     RCori = RCori, RWT = RWT,
                     elapsed = toc, penparam = lambdahat_mcmc, K = K,
                     NegBinoverdisp = rhohat_mcmc, method = "LPSMALA")

  attr(outputlist, "class") <- "epilps"
  outputlist
}


